= Developing a Custom Response Policy
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

When you are ready to develop your custom policy, follow the example described in this section to learn how to plan, develop, and implement your specific policy. You create your custom policy using the following steps:

. <<set-up-the-project, Set up your project>>
. <<create_the_YAML, Create the YAML Configuration File>>
. <<implment_the_policy, Implement your policy>>
. <<upload_to_exchange, Upload your policy to Exchange>>
. <<apply_custom_policy, Apply your custom policy>>


== The Use Case

To better understand how to implement a custom policy, let us look at the example of the Good Weather company, which is in the business of forecasting weather that predicts the atmospheric conditions for a given location and time. Good Weather collects quantitative data about the current state of the atmosphere at a given place and using meteorology.

Based on the current weather patters, Good Weather want to provide the capability to add custom responses to the weather forecast in the consuming application. The application must be able to manipulate the status code and response message based on a series of conditions that are evaluated on each request.

Telstra is an IT company that develops operating systems and applications for mobile and home computing technologies. Telstra wants to integrate with Good Weather to be able to display daily weather forecasts on mobiles and PCs.

*<Lorena, can we build on this example? Why would this company now want to create a custom repsonse policy?>*

Good Weather uses an HTTP Proxy with a Basic Authentication policy applied to it. Each time a request arrives, the Basic Authentication policy checks the bearer token and performs one of the following tasks:

* Allow the request to reach the backend, or 
* If the validation is not successful, the policy is returned with a 401 Unauthorized Status Code.

But what if, in case of unauthorized access, Telstra wants to include a different message each time it receives a 401 error. Developing a custom response policy allows Telstra to change the response message and status code based on a series of different conditions. For example, Telstra can state that if the response contains an Unauthorized status code, they mofidy the response payload accordingly.

The following sections explain how to create this custom policy.

[[set-up-the-project]]
== Setting Up the Project

When you create a custom policy, your start with creating a xref:custom-policy-getting-started.adoc[custom policy Archetype project]. To get started, run the archetype, replacing the parameters in bold with the ones of your need. The example uses the following details:

* The `DgroupId` parameter uses your Organization ID. 
* The `DartifactId` parameter uses the `custom-response-policy` value. You can set it to any other value as required.
* The `Dversion` parameter uses 1.0.0 as the value.
*  The `DartifactId` and `Dversion` parameters do not have any restrictions.


[source,console,linenums]
----
mvn -Parchetype-repository archetype:generate \
-DarchetypeGroupId=org.mule.tools \
-DarchetypeArtifactId=api-gateway-custom-policy-archetype \
-DarchetypeVersion=1.1.0 \
-DgroupId=<your_organization_ID> \
-DartifactId=custom-response-policy \
-Dversion=1.0.0 \
-Dpackage=mule-policy
----

[[create_the_YAML]]
== Creating the YAML Configuration File

After you set up a project, you are now ready to start adding dependencies and components to your custom policy. You start by defining the input parameters of the policy to configure in API Manager. The example in this section uses the following events flow:

* First the conditions used to evaluate the request and response is specified.
* If conditions are parametric, then Dataweave expressions are created.
* A check is performed to verify whether the conditions are met at the same time.
* The status code set in case the conditions are met.
* The payload is set in case the conditions are met.

Example YAML File For the Policy UI:

[source,YAML,linenums]
----
  id: Custom Response
  name: Custom Response
  description: Modifies the payload and/or the status code when some condition is met.
  category: Custom
  type: custom
  resourceLevelSupported: true
  encryptionSupported: false
  standalone: true
  requiredCharacteristics: []
  providedCharacteristics: []
  configuration:
   - propertyName: evaluateInRequest
     name: Evaluate in the request
     description: If the condition should be evaluated in the request.
     type: boolean
     optional: true
     defaultValue: false
   - propertyName: requestCondition
     name: Request Condition
     description: Dataweave expression that will be evaluated to define if the request should be modified.
     type: expression
     optional: true
     sensitive: false
     allowMultiple: false
     dependsOnKey: evaluateInRequest
     dependsOnValue: true
   - propertyName: evaluateInResponse
     name: Evaluate in the response
     description: If the condition should be evaluated in the response.
     type: boolean
     optional: true
     defaultValue: false
   - propertyName: responseCondition
     name: Response Condition
     description: Dataweave expression that will be evaluated to define if the request should be modified.
     type: expression
     optional: true
     sensitive: false
     allowMultiple: false
     dependsOnKey: evaluateInResponse
     dependsOnValue: true
   - propertyName: mergeBothConditions
     name: Merge both conditions
     description: Check if both request and response conditions need to be met.
     type: boolean
     optional: true
     defaultValue: false
   - propertyName: statusCode
     name: Status Code
     type: int
     minimumValue: 0
     maximumValue: 999
     description: Status code to return when the condition is met.
     optional: true
     sensitive: false
     allowMultiple: false
   - propertyName: payload
     name: Payload
     type: expression
     description: Expression that sets the payload to return when the condition is met.
     optional: true
     sensitive: false
     allowMultiple: false
----

In the example, the `dependsOnKey` and `dependsOnValue` parameters specify that the key indicated in `dependsOnKey` must be set to the value indicated in `dependsOnValue`, to display the fields `responseCondition` or `requestCondition`.

In the UI, this translates to a checkbox in `evaluateInTheRequest` or `evaluateInTheResponse`, that will make the field `responseCondition` or `requestCondition` appear depending on the value of the checkbox.

For more information about how to set up of the YAML file, see xref:custom-policy-4-reference#yaml-configuration-file[YAML Configuration File documentation].

Based on the example, the UI is generated as:

image::custom-response-policy-ui.png[custom-response-policy]

The following screenshot illustrates the `dependsOnKey` and `dependsOnValue` parameters:

image::depends-on-key-demo.png[depends-on-key-demo]

[[implment_the_policy]]
== Implementing the Policy

Now that you have defined the input parameters for your policy, you can start with implementing your policy. To implement your policy, you:

. Add your dependencies in the `pom.xml` file.
. Add conditions in the `template.xml` file.

=== Add Dependencies in POM.XML File

In your `pom.xml`, include all the dependencies that you need to use. In this case, you only need the `http-policy-transform-extension`, which will help you to easily modify the response information.

*<Lorena, why do they need to do this? How does it help?>*

In the `<dependencies>` section of the policy pomXML file, include the following dependencies:

[source,XML,linenums]
----
<dependency>
   <groupId>com.mulesoft.anypoint</groupId>
   <artifactId>mule-http-policy-transform-extension</artifactId>
   <version>${httpPolicyTransformVersion}</version>
   <classifier>mule-plugin</classifier>
</dependency>
----

=== Add Conditions in Template.XML File

*<Lorena, why do they need to do this? How does it help?>*
Next, in the `template.xml` file, you must include the following code:

[source,XML,linenums]
----
{{#if evaluateInRequest}}
<set-variable variableName="requestConditionMet" value="{{{requestCondition}}}" />
{{/if}}
<http-policy:execute-next/>
{{#if evaluateInResponse}}
<set-variable variableName="responseConditionMet" value="{{{responseCondition}}}" />
{{/if}}
----

Note that the pieces of code in double braces correspond to xref:custom-policy-4-reference#handlebars[Handlebars] syntax, which uses a template engine to compose the policy template with the configuration defined in the YAML file. The values used to configure the template must be the keys defined earlier in the YAML Configuration File. Both values must match. Misspelling in any of the parameters can generate errors when developing custom policies.

In the above example, the parameters `evaluateInRequest` and `evaluateInResponse` define elements that will hold the value of the condition to be evaluated, defined in `requestCondition` and `responseCondition`.

For example when you configure your policy, you want to check if a particular header is present in the request. However, you do not want to check anything in the response. In this case, your policy configuration will look like this:

image::custom-response-configuration.png[custom-response-configuration]

When deployed, the template will be resolved as displayed in the following code example. This is because you did not specify any response condition. Therefore, the Handlebars will not include it in the resolved template.

[source,XML,linenums]
----
<set-variable variableName="requestConditionMet" value="#[attributes.headers['X-MyHeader'] == 'MyValue']" />
<http-policy:execute-next/>
----

You can now complete the logic of your template file with the following code:

[source,XML,linenums]
----
<choice>
   {{#if mergeBothConditions}}
   <when expression="#[(vars.requestConditionMet default false) and (vars.responseConditionMet default false)]" >
       {{#if statusCode}}
       <set-variable variableName="statusCode" value="{{statusCode}}" />
       {{/if}}

       {{#if payload}}
       <set-variable variableName="payload" value="{{{payload}}}" />
       {{/if}}

       <http-transform:set-response statusCode="#[vars.statusCode default attributes.statusCode]">
           <http-transform:body>#[vars.payload default payload]</http-transform:body>
           <http-transform:headers>#[attributes.headers]</http-transform:headers>
       </http-transform:set-response>
   </when>
   {{else}}
   <when expression="#[(vars.requestConditionMet default false) or (vars.responseConditionMet default false)]" >
       {{#if statusCode}}
       <set-variable variableName="statusCode" value="{{statusCode}}" />
       {{/if}}

       {{#if payload}}
       <set-variable variableName="payload" value="{{{payload}}}" />
       {{/if}}

       <http-transform:set-response statusCode="#[vars.statusCode default attributes.statusCode]">
           <http-transform:body>#[vars.payload default payload]</http-transform:body>
           <http-transform:headers>#[attributes.headers]</http-transform:headers>
       </http-transform:set-response>
   </when>
   {{/if}}
</choice>
----

To modify the payload and the status code, if set, you use the `http-policy-transform-extension` that is included in the dependencies at the beginning of this section. *<Lorena, where is this? Can we highlight>*

Notice how Handlebars is used to resolve pieces of the template, like we recently explained.

Your brand new Custom Response Policy is now ready. You can now upload the policy to Exchange and test it.

[[upload_to_exchange]]
== Uploading to Exchange

To upload a custom policy to Exchange, you must verify whether you in your `pom.xml`` file is correctly configured for your organization.

First, you must configure a new server in your Maven `settings.xml` file. Assign it a unique ID, and the username and password of your Exchange credentials.

=== Task Prerequisites

Before you upload your policy to Exchange, verify that:

* The URL matches the one of your region. By default, the archetype sets the URL that corresponds to the US region.
* The repository ID matches the one from the Maven settings. 
+
Tip: You can define an alias to that repository using the name tag.

[source,XML,linenums]
----
<servers>
      <server>
         <id>your_server_id</id>
         <username>your_username</username>
         <password>your_password</password>
       </server>
</servers>
----

Then, go to your policy `pom.xml` file` and locate the `distributionManagement` section.

[source,XML,linenums]
----
<distributionManagement>
    <repository>
        <id>your_server_id</id>
        <name>My Repository</name>
        <url>${exchange.url}</url>
        <layout>default</layout>
    </repository>
</distributionManagement>
----

After you check the configuration of the servers, begin uploading your policy to Exchange using the following command:

[source,console,linenums]
----
> mvn deploy
----

Your policy is now uploaded to Exchange.

[[apply_custom_policy]]
== Applying the Policy

You apply a custom policy the same way as you apply a Default policy. When you go to API Manager, you can see the new policy available and ready to configure and use:

image::custom-response-policy-platform.png[custom-response-policy-platform]

To see the full example of the custom policy, see to xref:https://github.com/mulesoft/api-gateway-custom-policies-examples[Custom Policies Examples] Github repository.
